# -*- coding: utf-8 -*-
"""Lab3_Matrix_Operations

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xQeNIOVwdPZ-eZknNVtCNXKUO5hYrryA

Harsh Dineshkuamar Patel 

AU2140022

DSA_Section_1
"""

#Program_1 

class Array2D():
    def __init__(self, nrows, ncolumns):
        self.nrows = nrows
        self.ncolumns = ncolumns
        self.mat = [[None for i in range(ncolumns)] for j in range(nrows)]

    def numRows(self):
            return self.nrows

    def numColumns(self):
            return self.ncolumns

    def clear( self, value ):
        for i in range(self.nrows):
            for j in range(self.ncolumns):
                self.mat[i][j] = value
        Array2D.printArray2D(self)
        return " "

    def getitem(self,i1,i2 ):
        if i1 <= self.nrows and i2 <= self.ncolumns:
            print(self.mat[i1-1][i2-1],"\n")
        else :
            print(" : !Error! : Invalid Index Number : ")
            return " "

    def setitem(self,i1,i2,value):
        if i1 <= self.nrows and i2 <= self.ncolumns:
            self.mat[i1-1][i2-1] = value
            Array2D.printArray2D(self)
        else :
            print(" : !Error! : Invalid Index Number : ")
            return " "

    def printArray2D(self):
        print("\n")
        for i in range(self.nrows):
            for j in range(self.ncolumns):
                print(self.mat[i][j],end="   ")
            print("\n")
        return " " 

A = Array2D(3,3)
A.printArray2D()
A.clear(2)
A.getitem(1,2)
A.setitem(1,3,10)

#Program_2

def displayMatrix(matrix):
    for row in matrix:
        for element in row:
            print(element, end=" ")
        print()

class Array2D:
    def __init__(self,nrows,ncols):
        self.nrows=nrows
        self.ncols = ncols
        self.sparray=[]
    def numrow(self):
        return self.nrows

    def numcol(self):
        return self.ncols

    def clear(self,value):

        b=[]
        for i in range(self.nrows):
            for j in range(self.ncols):
                b.append([i,j,value])
        self.sparray=b


    def getitems(self,i1,i2):
        for i in range(len(self.sparray)):
            for x,y,z in self.sparray:
                if(x==i1 and y==i2):
                    return z
        return 0

    def setitems(self,i1,i2,value):
        c=0
        for i in range(len(self.sparray)):
            if (self.sparray[i][0]==i1 and self.sparray[i][1]==i2 ):
                self.sparray[i][2]=value
                c=c+1
        if(c==0):
            self.sparray.append([i1,i2,value])

A = Array2D(4,3)
print(A.sparray)
A.setitems(1,8,3)
A.setitems(9,2,7)
A.setitems(10,3,3)
A.setitems(1,4,4)
print(A.getitems(2,2))
print(A.getitems(1,2))
print(A.sparray)

#Program_3

class Matrix:

    def __init__(self, r, c):
        self.MAX = 100
        self.data = [None for i in range(self.MAX)]
        for i in range(self.MAX):
            self.data[i] = [None for i in range(3)]

        self.row = r
        self.col = c

        self.len = 0
    def insert(self, r, c, val):
        if (r > self.row or c > self.col):
            print("Wrong entry")
        else:
            self.data[self.len][0] = r
            self.data[self.len][1] = c
            self.data[self.len][2] = val
            self.len += 1
    def scaleBy(self,scalar):
        for i in range(self.len):
            self.data[i][2]=self.data[i][2]*scalar
        print(self.data)

    def getitem (self,row,col):
        if (row > self.row or col > self.col):
            print("Wrong entry")
        else:
            print('')


    def add(self, b):
        if (self.row != b.row or self.col != b.col):
            print("Matrices can't be added")
        else:

            apos = 0
            bpos = 0
            result = Matrix(self.row, self.col)

            while (apos < self.len and bpos < b.len):
                if (self.data[apos][0] > b.data[bpos][0] or (
                        self.data[apos][0] == b.data[bpos][0] and self.data[apos][1] > b.data[bpos][1])):

                    result.insert(b.data[bpos][0],
                                  b.data[bpos][1],
                                  b.data[bpos][2])
                    bpos += 1

                elif (self.data[apos][0] < b.data[bpos][0] or (
                        self.data[apos][0] == b.data[bpos][0] and self.data[apos][1] < b.data[bpos][1])):

                    result.insert(self.data[apos][0], self.data[apos][1], self.data[apos][2])
                    apos += 1

                else:
                    addedval = self.data[apos][2] + b.data[bpos][2]

                    if (addedval != 0):
                        result.insert(self.data[apos][0], self.data[apos][1], addedval)
                    apos += 1
                    bpos += 1

            while (apos < self.len):
                result.insert(self.data[apos][0], self.data[apos][1], self.data[apos][2])
                apos += 1

            while (bpos < b.len):
                result.insert(b.data[bpos][0], b.data[bpos][1], b.data[bpos][2])
                bpos += 1
            result.print()

    def transpose(self):

        result = Matrix(self.col, self.row)
        result.len = self.len
        count = [None for _ in range(self.col + 1)]
        for i in range(1, 1 + self.col):
            count[i] = 0

        for i in range(0, self.len):
            count[self.data[i][1]] += 1

        index = [None for _ in range(self.col + 1)]
        index[1] = 0
        for i in range(2, 1 + self.col):
            index[i] = index[i - 1] + count[i - 1]

        for i in range(self.len):
            rpos = index[self.data[i][1]]
            index[self.data[i][1]] += 1
            result.data[rpos][0] = self.data[i][1]
            result.data[rpos][1] = self.data[i][0]
            result.data[rpos][2] = self.data[i][2]

        return result

    def multiply(self, b):
        if (self.col != b.row):

            print("Can't multiply, Invalid dimensions")
            return

        b = b.transpose()

        result = Matrix(self.row, b.row)

        for apos in range(self.len):

            r = self.data[apos][0]

            for bpos in range(b.len):

                c = b.data[bpos][0]

                tempa = apos
                tempb = bpos
                sum = 0

                while (tempa < self.len and self.data[tempa][0] == r and tempb < b.len and b.data[tempb][0] == c):

                    if (self.data[tempa][1] < b.data[tempb][1]):
                        tempa += 1

                    elif (self.data[tempa][1] > b.data[tempb][1]):
                        tempb += 1
                    else:
                        sum += self.data[tempa][2] * b.data[tempb][2]
                        tempa += 1
                        tempb += 1
                if (sum != 0):
                    result.insert(r, c, sum)
                while (bpos < b.len and b.data[bpos][0] == c):
                    bpos += 1

            while (apos < self.len and self.data[apos][0] == r):
                apos += 1

        result.print()

    def print(self):
        print("Dimension:", self.row, "x", self.col)
        print("Sparse Matrix: \nRow Column Value")

        for i in range(self.len):
            print(self.data[i][0], self.data[i][1], self.data[i][2])


a = Matrix(2,2)
b = Matrix(2,2)

a.insert(1, 2, 10)
a.insert(1, 4, 12)

b.insert(1, 3, 8)
b.insert(2, 4, 23)

a.scaleBy(2)

print("Addition: ")
a.add(b)
print("\nMultiplication: ")
a.multiply(b)
print("\nTranspose: ")
atranspose = a.transpose()
atranspose.print()

#Program_4

class Game_of_Life:

    def __init__(self,rows,cols):
        self.array=[0]*rows
        for i in range(rows):
            self.array[i]=[0]*cols

    def numrow(self):
        return len(self.array)

    def numcol(self):
        return len(self.array[0])

    def print2d(self):
        for i in range(len(self.array)):
            for j in range(len(self.array[0])):
                print(self.array[i][j],end=" ")
            print("")

    def configure(self,coordList):
        # coordlist=[(r1,c1),(r2,c2)...]
        for r,c in coordList:
            self.array[r][c]=1
        self.print2d()

    def clearCell(self,row,col):
        if (row <= len(self.array) and col<= len(self.array[0])):
            self.array[row][col] = 0
        else:
            print("Enter valid row and column value")

    def setCell(self,row,col):
        if (row <= len(self.array) and col<= len(self.array[0])):
            self.array[row][col] = 1
        else:
            print("Enter valid row and column value")

    def isLiveCell(self,row,col):
        if (row <= len(self.array) and col<= len(self.array[0])):
            return self.array[row][col] == 1
        else:
            print("Enter valid row and column value")

    def numLiveNeighbors(self ,row, col):
        trav = [(0,1),(1,0),(-1,0),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]
        count = 0
        for x,y in trav:
            if(0<=row+x<len(self.array) and 0<=col+y<len(self.array[0]) and self.array[row+x][col+y]==1):
                count=count+1
        return count

    def start(self,row,col):
        count = self.numLiveNeighbors(row,col)
        if(self.array[row][col]==1):
            if 2<=count<=3:
                return 1
            else:
                return 0
        else:
            if count == 3:
                return 1
            else:
                return 0

    def final_solution(self):
        c=0
        while c!=10:
            for i in range(len(self.array)):
                for j in range(len(self.array[0])):
                    self.array[i][j]=self.start(i,j)
            print("Final")
            self.print2d()
            c = c + 1

tmp = Game_of_Life(5,6)
tmp.configure([(0,0),(0,1),(2,2),(1,0),(4,4),(4,5),(3,5)])
tmp.final_solution()