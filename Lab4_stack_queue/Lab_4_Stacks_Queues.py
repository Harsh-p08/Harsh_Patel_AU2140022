# -*- coding: utf-8 -*-
"""Lab_4_Stacks_Queues

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uMA1Q6wGf61lcWaLzq_aZeEva0Tpkhob

Name : Harsh Dineshkumar Patel


Roll No. : AU2140022


DSA Section 1
"""

#Problem_1

class Stack :

    # Creates an empty stack.
    def __init__( self ): 
        self._top = None 
        self._size = 0
    
    # Returns True if the stack is empty or False otherwise.
    def isEmpty( self ): 
        return self._top is None
    
    # Returns the number of items in the stack.
    def length( self ): 
        return self._size

    # Returns the top item on the stack without removing it.
    def peek( self ):
        assert not self.isEmpty(), "Cannot peek at an empty stack" 
        return self._top.item
    
    # Removes and returns the top item on the stack.
    def pop( self ):
        assert not self.isEmpty(), "Cannot pop from an empty stack" 
        node = self._top
        self._top = self._top.next
        self._size = self._size - 1
        return node.item
    
    # Pushes an item onto the top of the stack.
    def push( self, item ) :
        self._top = _StackNode( item, self._top ) 
        #print("top is -->",item,self._top)
        self._size += 1

    def display( self ):
      tmp = self._top
      while tmp!= None:
          print(tmp.item)
          tmp = tmp.next

        
# The private storage class for creating stack nodes.
class _StackNode :
    def __init__( self, item, link ) :
        #print(item,"points to:",link)
        self.item = item
        self.next = link

stack = Stack()
stack.push(11)
stack.push(26)
stack.push(52)
stack.push(86)
stack.push(92)
print(stack.isEmpty())
print("\n")
print(stack.peek())
print("\n")
print(stack.length())
print("\n")
stack.display()
print("\n")
print(stack.pop())
print("\n")
print(stack.length())
print("\n")
stack.display()
print("\n")

#Problem_2

class Stack :

    # Creates an empty stack.
    def __init__( self ): 
        self._top = None 
        self._size = 0
    
    # Returns True if the stack is empty or False otherwise.
    def isEmpty( self ): 
        return self._top is None
    
    # Returns the number of items in the stack.
    def length( self ): 
        return self._size

    # Returns the top item on the stack without removing it.
    def peek( self ):
        assert not self.isEmpty(), "Cannot peek at an empty stack" 
        return self._top.item
    
    # Removes and returns the top item on the stack.
    def pop( self ):
        assert not self.isEmpty(), "Cannot pop from an empty stack" 
        node = self._top
        self._top = self._top.next
        self._size = self._size - 1
        return node.item
    
    # Pushes an item onto the top of the stack.
    def push( self, item ) :
        self._top = _StackNode( item, self._top ) 
        #print("top is -->",item,self._top)
        self._size += 1

    def postfix( self , item ):
        
        item = item.split()
        for chr in item: 
          if chr.isdigit():
            self.push(int(chr))
          else:
            n1 = self.pop()
            n2 = self.pop()
            ch = ord(chr)
            if (ch == 43):
              self.push(n1 + n2)
              n = n1 + n2
            elif (ch == 45):
              self.push(n2 - n1)
              n = n2 - n1
            elif (ch == 42):
              self.push(n1 * n2)
              n = n1 * n2
            elif (ch == 47):
              self.push(n2 / n1)
              n = n2 / n1
        return n  
      
# The private storage class for creating stack nodes.
class _StackNode :
    def __init__( self, item, link ) :
        #print(item,"points to:",link)
        self.item = item
        self.next = link

stack = Stack()
e = input("Enter postfix Expression: ")
stack.postfix(e)

#Problem_3  

class Stack :
    def __init__(self):
        self.head = None
        self.size = 0

    # Returns boolean expression
    def isEmpty(self):
        return (self.head == None)

    #returns the size of the stack
    def len_(self):
        return self.size 
    
    def CheckBalance(self):
        ip = input("Enter : ")
        oc = ["(","[","{"]
        ip = ip.replace(" ","")
        for i in range(len(ip)):
            if(ip[i] == "/" and ip[i+1] == "/"):
                break 
            if(ip[i] in oc):
                Stack.push(self, ip[i])
            else:
                if(ip[i] == ")"):
                    if (Stack.peek(self) != "(" or Stack.isEmpty == True):
                        Stack.push(self,1)
                        Stack.disp(self)
                        break
                    a = Stack.pop(self)
                if(ip[i] == "]"):
                    if (Stack.peek(self) != "[" or Stack.isEmpty == True):
                        Stack.push(self,1)
                        Stack.disp(self)
                        break
                    a = Stack.pop(self)
                if(ip[i] == "}"):
                    if (Stack.peek(self) != "{" or Stack.isEmpty == True):
                        Stack.push(self,1)
                        Stack.disp(self)
                        break
                    a = Stack.pop(self)                    
        if(Stack.isEmpty(self) == True):
            print(" :=> Balanced :-)")
            return " "
        else:
            return "!Error! : Invalid Expresion ! "

    #Push Stack
    def push(self, data):
        
        #New StackNode
        newStackNode = StackNode(data)
        
        #Linking New stackNode
        if self.head == None:
            self.head = newStackNode
            self.size +=1
        else:
            newStackNode.next = self.head
            self.head = newStackNode
            self.size +=1
        
    #Pop Stack
    def pop(self):
        # assert self.head != None, " Cannot pop from empty stack :-( "
        data = self.head.data
        self.head = self.head.next
        self.size -=1
        return data
    
    # the peek of the Stack
    def peek(self):
        # assert self.head != None, "Empty stack does not hav peek :-( "
        return self.head.data

    
    # Printing the Sack
    def disp(self):
        cur = self.head
        print("\n The Stack : ")
        for i in range(Stack.len_(self)):
            print(cur.data)
            cur = cur.next

class StackNode :
    def __init__(self, data) :
        self.data = data
        self.next = None

stack = Stack()
print(stack.CheckBalance())

#Problem 4

class Queue :
    # Creates an empty queue.
    def __init__( self ): 
        self._qList = list()

    # Returns True if the queue is empty.
    def isEmpty( self ): 
        return len( self ) == 0

    # Returns the number of items in the queue.
    def __len__ ( self ):
        return len( self._qList )

    # Adds the given item to the queue.
    def enqueue( self, item ):
        self._qList.append( item )

    # Removes and returns the first item in the queue.
    def dequeue( self ):
        assert not self.isEmpty(), "Cannot dequeue from an empty queue." 
        return self._qList.pop( 0 )

    # Display the Queue
    def display( self ):
      assert not self.isEmpty(), "Cannot Display an empty queue." 
      top = self.dequeue()
      while top != self.isEmpty():
        print(top)
        if self.isEmpty():
          return None
        else: 
          top = self.dequeue()


q = Queue()
q.isEmpty()

q.enqueue(11)
q.enqueue(26)
q.enqueue(52)
q.enqueue(86)
q.enqueue(92)
q.display()

#Problem 5

class Queue :
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    # Returns boolean expression
    def isEmpty(self):
        return (self.head == None)

    #returns the size of the Queue
    def length_(self):
        return self.size 

    #Enqueue 
    def enqueue(self,data,pr):
        
        #New QueueNode
        newQueueNode = QueueNode(data,pr)
        
        #Linking New stackNode
        #empty queue
        if self.tail == None: 
            self.head = newQueueNode
            self.tail = newQueueNode

         # The lower priority
        elif self.tail.priority <= newQueueNode.priority:
            self.tail.next = newQueueNode
            self.tail = newQueueNode

        #The Highest priority
        elif self.head.priority > newQueueNode.priority:
            newQueueNode.next = self.head
            self.head = newQueueNode

        # Checking priority and adding
        else:
            cur = self.head
            
            while cur.next != None:
                if (cur.next.priority > newQueueNode.priority):
                    break
                cur = cur.next

            newQueueNode.next = cur.next
            cur.next = newQueueNode

        self.size +=1


    def dequeue(self):
        assert self.tail != None, " Cannot dequeue from empty Queue :-( "
        data = self.head
        self.head = self.head.next
        self.size -=1
        return data


    def disp(self):
        cur = self.head
        for i in range(Queue.length_(self)):
            print(cur.data,end=" ")
            cur = cur.next
            
class QueueNode :
    def __init__(self,data,pr) :
        self.data = data
        self.priority = pr
        self.next = None

Q = Queue()
Q.length_()
Q.enqueue(11,1)
Q.enqueue(26,3)
Q.enqueue(52,0)
Q.enqueue(86,2)
Q.disp()

print("\t")

print(Q.isEmpty())
print(Q.length_())

#Problem 6

class QueueNode :
    def __init__(self, data) :
        self.data = data
        self.next = None

class Queue :
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    # Returns boolean expression
    def isEmpty(self):
        return (self.head == None)

    #returns the size of the Queue
    def length_(self):
        return self.size 

    #Enqueue
    def enqueue(self,data):
        
        #New QueueNode
        newQueueNode = QueueNode(data)
        
        #Linking New stackNode
        if self.tail == None:
            self.head = newQueueNode
            self.tail = newQueueNode
            self.size +=1
        else:
            self.tail.next = newQueueNode
            self.tail = newQueueNode
            self.size +=1
    
    def frontenqueue(self,data):
         #New QueueNode
        newQueueNode = QueueNode(data)

       #Linking New stackNode 
        if self.head == None:
            self.tail  = newQueueNode
            self.head = newQueueNode
        else:
            newQueueNode.next = self.head
            self.head = newQueueNode
        self.size +=1
        
    #dequeue
    def dequeue(self):
        assert self.tail != None, " Cannot dequeue from empty Queue :-( "
        data = self.head
        self.head = self.head.next
        self.size -=1
        return data.data

    def reardequeue(self):
        assert self.tail != None, " Cannot dequeue from empty Queue :-( "
        cur = self.head
        while cur.next.next != None:
            cur = cur.next
        cur.next = None
        self.tail = cur
        self.size -=1
        return " "
  
    # Printing the Queue
    def disp(self):
        cur = self.head
        print("\n The Queue : ")
        for i in range(Queue.length_(self)):
            print(cur.data,end=" ")
            cur = cur.next
            


Q = Queue()
Q.length_()
Q.enqueue(11)
Q.enqueue(26)
Q.enqueue(52)
Q.enqueue(86)
Q.disp()
print("\t")
print(Q.isEmpty())
print(Q.length_())
print("\t")
print(Q.dequeue())
print("\t")
print(Q.dequeue())
Q.disp()
Q.frontenqueue(10)
print("\t")
Q.disp()
print("\t")
print("\t")
print("The rear Dequeued Queue is ",Q.reardequeue())
Q.disp()